/**
 * Calculate the unique object ID based on the object information.
 * The ID will change if the object definition changes, this is intentional
 * and is used to avoid connecting objects with incompatible configurations.
 * The LSB is set to zero and is reserved for metadata
 */
void UAVObjectParser::calculateID(ObjectInfo *info)
{
    // Hash object name
    quint32 hash = updateHash(info->name, 0);

    // Hash object attributes
    hash = updateHash(info->isSettings, hash);
    hash = updateHash(info->isSingleInst, hash);
    // Hash field information
    for (int n = 0; n < info->fields.length(); ++n) {
        hash = updateHash(info->fields[n]->name, hash);
        hash = updateHash(info->fields[n]->numElements, hash);
        hash = updateHash(info->fields[n]->type, hash);
        if (info->fields[n]->type == FIELDTYPE_ENUM) {
            QStringList options = info->fields[n]->options;
            for (int m = 0; m < options.length(); m++) {
                hash = updateHash(options[m], hash);
            }
        }
    }
    // Done
    info->id = hash & 0xFFFFFFFE;
}

/**
 * Shift-Add-XOR hash implementation. LSB is set to zero, it is reserved
 * for the ID of the metaobject.
 *
 * http://eternallyconfuzzled.com/tuts/algorithms/jsw_tut_hashing.aspx
 */
quint32 UAVObjectParser::updateHash(quint32 value, quint32 hash)
{
    return hash ^ ((hash << 5) + (hash >> 2) + value);
}

/**
 * Update the hash given a string
 */
quint32 UAVObjectParser::updateHash(QString & value, quint32 hash)
{
    QByteArray bytes = value.toLatin1();
    quint32 hashout  = hash;

    for (int n = 0; n < bytes.length(); ++n) {
        hashout = updateHash(bytes[n], hashout);
    }

    return hashout;
}